      #############################################################
# 2D Features framework (feature2d module)  特征检测
      ##############################################################

# 【1】Harris角点  cornerHarris()

        算法基本思想是使用一个固定窗口在图像上进行任意方向上的滑动，
        比较滑动前与滑动后两种情况，窗口中的像素灰度变化程度，
        如果存在任意方向上的滑动，都有着较大灰度变化，
        那么我们可以认为该窗口中存在角点。

        图像特征类型:
            边缘 （Edges   物体边缘）
            角点 (Corners  感兴趣关键点（ interest points） 边缘交叉点 )
            斑点(Blobs  感兴趣区域（ regions of interest ） 交叉点形成的区域 )


        为什么角点是特殊的?
            因为角点是两个边缘的连接点(交点)它代表了两个边缘变化的方向上的点。
            图像梯度有很高的变化。这种变化是可以用来帮助检测角点的。


        G = SUM( W(x,y) * [I(x+u, y+v) -I(x,y)]^2 )

         [u,v]是窗口的偏移量
         (x,y)是窗口内所对应的像素坐标位置，窗口有多大，就有多少个位置
         w(x,y)是窗口函数，最简单情形就是窗口内的所有像素所对应的w权重系数均为1。
                     设定为以窗口中心为原点的二元正态分布

        泰勒展开（I(x+u, y+v) 相当于 导数）
        G = SUM( W(x,y) * [I(x,y) + u*Ix + v*Iy - I(x,y)]^2)
          = SUM( W(x,y) * (u*u*Ix*Ix + v*v*Iy*Iy))
          = SUM(W(x,y) * [u v] * [Ix^2   Ix*Iy] * [u 
                            Ix*Iy  Iy^2]     v] )
          = [u v]  * SUM(W(x,y) * [Ix^2   Ix*Iy] ) * [u  应为 [u v]为常数 可以拿到求和外面
                             Ix*Iy  Iy^2]      v]    
          = [u v] * M * [u
                   v]
        则计算 det(M)   矩阵M的行列式的值  取值为一个标量，写作det(A)或 | A |  矩阵表示的空间的单位面积/体积/..
               trace(M) 矩阵M的迹         矩阵M的对角线元素求和，用字母T来表示这种算子，他的学名叫矩阵的迹

        M的两个特征值为 lamd1  lamd2

        det(M)    = lamd1 * lamd2
        trace(M) = lamd1 + lamd2

        R = det(M)  -  k*(trace(M))^2 
        其中k是常量，一般取值为0.04~0.06，
        R大于一个阈值的话就认为这个点是 角点

        因此可以得出下列结论：
        >特征值都比较大时，即窗口中含有角点
        >特征值一个较大，一个较小，窗口中含有边缘
        >特征值都比较小，窗口处在平坦区域

        https://blog.csdn.net/woxincd/article/details/60754658

# 【2】 Shi-Tomasi 算法 goodFeaturesToTrack()
        是Harris 算法的改进。
        Harris 算法最原始的定义是将矩阵 M 的行列式值与 M 的迹相减，
        再将差值同预先给定的阈值进行比较。

        后来Shi 和Tomasi 提出改进的方法，
        若两个特征值中较小的一个大于最小阈值，则会得到强角点。
        M 对角化>>> M的两个特征值为 lamd1  lamd2

        R = mini(lamd1,lamd2) > 阈值 认为是角点


# 【3】FAST角点检测算法  ORB特征检测中使用的就是这种角点检测算法
              FAST(src_gray, keyPoints,thresh);
        周围区域灰度值 都较大 或 较小

              若某像素与其周围邻域内足够多的像素点相差较大，则该像素可能是角点。

        该算法检测的角点定义为在像素点的周围邻域内有足够多的像素点与该点处于不同的区域。
        应用到灰度图像中，即有足够多的像素点的灰度值大于该点的灰度值或者小于该点的灰度值。

        p点附近半径为3的圆环上的16个点，
        一个思路是若其中有连续的12个点的灰度值与p点的灰度值差别超过某一阈值，
        则可以认为p点为角点。

        这一思路可以使用机器学习的方法进行加速。
        对同一类图像，例如同一场景的图像，可以在16个方向上进行训练，
        得到一棵决策树，从而在判定某一像素点是否为角点时，
        不再需要对所有方向进行检测，
        而只需要按照决策树指定的方向进行2-3次判定即可确定该点是否为角点。

        std::vector<KeyPoint> keyPoints; 
        //fast.detect(src_gray, keyPoints);  // 检测角点
        FAST(src_gray, keyPoints,thresh);

# 【4】 使用cornerEigenValsAndVecs()函数和cornerMinEigenVal()函数自定义角点检测函数。
        过自定义 R的计算方法和自适应阈值 来定制化检测角点

        计算 M矩阵
        计算判断矩阵 R

        设置自适应阈值

        阈值大小为 判断矩阵 最小值和最大值之间 百分比
        阈值为 最小值 + （最大值-最小值）× 百分比
        百分比 = myHarris_qualityLevel/max_qualityLevel

# 【5】亚像素级的角点检测
        如果对角点的精度有更高的要求，可以用cornerSubPix()函数将角点定位到子像素，
        从而取得亚像素级别的角点检测效果。

        使用cornerSubPix()函数在goodFeaturesToTrack()的角点检测基础上将角点位置精确到亚像素级别

        常见的亚像素级别精准定位方法有三类：
          1. 基于插值方法
          2. 基于几何矩寻找方法
          3. 拟合方法 - 比较常用

        拟合方法中根据使用的公式不同可以分为
          1. 高斯曲面拟合与
          2. 多项式拟合等等。

        以高斯拟合为例:

          窗口内的数据符合二维高斯分布
          Z = n / (2 * pi * 西格玛^2) * exp(-P^2/(2*西格玛^2))
          P = sqrt( (x-x0)^2 + (y-y0)^2)

          x,y   原来 整数点坐标
          x0,y0 亚像素补偿后的 坐标 需要求取

          ln(Z) = n0 + x0/(西格玛^2)*x +  y0/(西格玛^2)*y - 1/(2*西格玛^2) * x^2 - 1/(2*西格玛^2) * y^2
            n0 +            n1*x + n2*y +             n3*x^2 +              n3 * y^2

          对窗口内的像素点 使用最小二乘拟合 得到上述 n0 n1 n2 n3
            则 x0 = - n1/(2*n3)
               y0 = - n2/(2*n3)
